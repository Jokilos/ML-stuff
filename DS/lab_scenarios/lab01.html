<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="F. Plata, K. Iwanicki, M. Banaszek, W. Ciszewski" />
  <title>Distributed Systems Lab 01</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
body
{
font-family: Helvetica, sans;
background-color: #f0f0f0;
font-size: 12pt;
color: black;
text-decoration: none;
font-weight: normal;
}
section.content {
width: 19cm;
font-size: 12pt;
text-align: justify;
margin-left: auto;
margin-right: auto;
margin-top: 20pt;
background-color: white;
padding: 20pt;
}
h1
{
font-size: xx-large;
text-decoration: none;
font-weight: bold;
text-align: center;
}
h2
{
font-size: xx-large;
text-decoration: none;
font-weight: bold;
text-align: left;
border-bottom: 1px solid #808080;
}
h3
{
font-size: x-large;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h1 + h3 {
text-align: center;
}
h4
{
font-size: large;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h5
{
font-size: medium;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h6
{
font-size: medium;
text-decoration: none;
font-weight: normal;
text-align: left;
}
table
{
border-width: 1px;
border-spacing: 0px;
border-style: solid;
border-color: #808080;
border-collapse: collapse;
font-family: Times, serif;
font-size: 12pt;
color: black;
text-decoration: none;
font-weight: normal;
background-color: white;
}
td
{
border-width: 1px;
border-style: solid;
border-color: #808080;
padding: 3pt;
background-color: white;
}
th
{
border-width: 1px;
border-style: solid;
border-color: #808080;
padding: 3pt;
font-weight: bold;
background-color: #f0f0f0;
}
a:link {
color: blue;
text-decoration: none;
font-weight: normal;
}
a:visited {
color: blue;
text-decoration: none;
font-weight: normal;
}
a:hover {
text-decoration: underline;
font-weight: normal;
}
pre.sourceCode {
font-size: 90%;
}
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<section id="distributed-systems-lab-01" class="content">
<h1>Distributed Systems Lab 01</h1>
<h3 id="introduction-to-rust-and-organization-of-the-labs">Introduction to Rust and Organization of the Labs</h3>
<p>Welcome to the Distributed Systems laboratory classes! Before proceeding, please, read additional information about the <a href="../L00/">organization of the labs</a>.</p>
<p>This lab introduces the Rust programming language. We will use files contained in <a href="./dslab01.tgz">this package</a>, which you should download and extract locally.</p>
<h2 id="learning-section">Learning Section</h2>
<h3 id="why-rust">Why Rust?</h3>
<p>Although the theory of distributed systems is not related to any specific programming language, during the labs we will use <a href="https://www.rust-lang.org/"><strong>Rust</strong></a> to implement discussed distributed algorithms. It is a compiled language which aims at <strong>efficiency</strong> by providing zero (or low) cost abstractions, and <strong>reliability</strong> by assuring memory-safety and thread-safety at compile-time, making it an ideal choice for the labs. You are not expected to already know Rust, as the first few labs are dedicated to learning the language.</p>
<h3 id="installing-rust">Installing Rust</h3>
<p>Follow the instructions on the <a href="https://www.rust-lang.org/tools/install">Install Rust</a> website. Verify that your installation works by running the following commands:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource bash numberLines"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="ex">rustc</span> --version</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ex">cargo</span> --version</span></code></pre></div>
<p>You can compile a single Rust file with:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource bash numberLines"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="ex">rustc</span> main.rs</span></code></pre></div>
<p>However, Rust has a tool for building and managing projects, called <strong><em>cargo</em></strong>. Usually, there is no need to call <em>rustc</em> directly and, in fact, it is not recommended, as its options can be changed without a notice.</p>
<h3 id="cargo">Cargo</h3>
<p>Essentially, <em>Cargo</em> is a <strong>package manager</strong> for Rust. It takes care of downloading and preparing dependencies (libraries, called <strong>crates</strong>) of a package. Each package includes a manifest file, <code>Cargo.toml</code>, which, in addition to the dependencies, also lists the basic metadata and configuration of the package. For instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource toml numberLines"><code class="sourceCode"><span id="cb3-1"><a href="#cb3-1"></a># General information about the package:</span>
<span id="cb3-2"><a href="#cb3-2"></a>[package]</span>
<span id="cb3-3"><a href="#cb3-3"></a>name = &quot;lab-01&quot;</span>
<span id="cb3-4"><a href="#cb3-4"></a>version = &quot;0.1.0&quot;</span>
<span id="cb3-5"><a href="#cb3-5"></a>authors = [&quot;Filip Plata &lt;fp371335@students.mimuw.edu.pl&gt;&quot;]</span>
<span id="cb3-6"><a href="#cb3-6"></a>edition = &quot;2021&quot;</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a># Crates required by this package.</span>
<span id="cb3-9"><a href="#cb3-9"></a># You can browse the Rust crate registry at https://crates.io:</span>
<span id="cb3-10"><a href="#cb3-10"></a>[dependencies]</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a># Dependencies required only by examples and tests:</span>
<span id="cb3-13"><a href="#cb3-13"></a>[dev-dependencies]</span>
<span id="cb3-14"><a href="#cb3-14"></a>ntest = &quot;0.7&quot;</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a># Binary target settings.</span>
<span id="cb3-17"><a href="#cb3-17"></a># E.g., path to a file which defines the main function of the binary:</span>
<span id="cb3-18"><a href="#cb3-18"></a>[[bin]]</span>
<span id="cb3-19"><a href="#cb3-19"></a>path = &quot;main.rs&quot;</span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a># See more keys and their definitions at</span>
<span id="cb3-23"><a href="#cb3-23"></a># https://doc.rust-lang.org/cargo/reference/manifest.html.</span></code></pre></div>
<p><em>Cargo</em> is also a <strong>command line tool</strong> for performing common tasks on a package. The basic commands that we will use are:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource bash numberLines"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># Compile the package:</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ex">cargo</span> build</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co"># Run the main function of the package</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"># (when run in the directory with Cargo.toml file):</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="ex">cargo</span> run</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co"># Run tests for the package:</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="ex">cargo</span> test</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co"># Format source code in the package:</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="ex">cargo</span> fmt</span>
<span id="cb4-13"><a href="#cb4-13"></a></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co"># Perform analysis of the source code to get hints on potential</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co"># problems and possible simplifications. Makes it easier to write</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co"># idiomatic code:</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="ex">cargo</span> clippy</span>
<span id="cb4-18"><a href="#cb4-18"></a></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="co"># Generate HTML documentation from doc comments:</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="ex">cargo</span> doc</span></code></pre></div>
<p>The default result of running <em>cargo</em> is a <em>debug</em> build. To change the target to <em>release</em>, add the <code>--release</code> flag to <em>cargo</em> commands.</p>
<h3 id="editors-for-programming-in-rust">Editors for programming in Rust</h3>
<p>Visit the <a href="https://www.rust-lang.org/tools">Rust website</a> for a list of editors/IDEs that are known to have a Rust integration available. <a href="https://code.visualstudio.com/">Visual Studio Code</a> seems to be the most popular one among the Rust community. Another option, which is not mentioned on the website and is available for free for students (at the time of writing this text), is <a href="https://www.jetbrains.com/clion/">CLion</a> with a Rust plugin (with a native debugger built in).</p>
<p>For Rust support in editors, you should use <a href="https://github.com/rust-lang/rust-analyzer">rust-analyzer</a>. Previously <a href="https://github.com/rust-lang/rls">Rust Language Server (RLS)</a> was used in many editors, but it has been deprecated and is no longer supported.</p>
<p>During the labs you can use whichever editor you prefer. The examples and assignments will be built and tested using <em>cargo</em>. However, it is advisable to have a comfortable setup to code in Rust.</p>
<h3 id="learning-rust">Learning Rust</h3>
<p>Assuming that you already know a few programming languages, we will just shortly highlight the most characteristic features of Rust.</p>
<p>Let us start with variables. They are declared using a <code>let</code> keyword. By default, variables are <strong>immutable</strong>. If you want to be allowed to modify their values, use also a <code>mut</code> keyword to declare them as <strong>mutable</strong>. For example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">let</span> i1<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">// Won&#39;t compile:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">// i1 = 43;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="pp">println!</span>(<span class="st">&quot;Immutable i32: {}&quot;</span><span class="op">,</span> i1)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">let</span> <span class="kw">mut</span> i2<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>i2 <span class="op">=</span> <span class="dv">43</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="pp">println!</span>(<span class="st">&quot;Mutable i32: {}&quot;</span><span class="op">,</span> i2)<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">let</span> a1<span class="op">:</span> [<span class="dt">u32</span><span class="op">;</span> <span class="dv">2</span>] <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">// Won&#39;t compile:</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">// a1[0] = 42;</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="pp">println!</span>(<span class="st">&quot;Immutable array with two u32 values: {:?}&quot;</span><span class="op">,</span> a1)<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co">// Above `{:?}` marker displays arrays for debugging purposes.</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co">// Arrays don&#39;t implement user-friendly formatting (the `{}` marker).</span></span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="kw">let</span> <span class="kw">mut</span> a2<span class="op">:</span> [<span class="dt">u32</span><span class="op">;</span> <span class="dv">2</span>] <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>a2[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="pp">println!</span>(<span class="st">&quot;Mutable array with two u32 values: {:?}&quot;</span><span class="op">,</span> a2)<span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="kw">let</span> v1<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i64</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="co">// Above `vec!` is a macro which simplifies creation of vectors.</span></span>
<span id="cb5-23"><a href="#cb5-23"></a><span class="co">// Won&#39;t compile:</span></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="co">// v1.truncate(1);</span></span>
<span id="cb5-25"><a href="#cb5-25"></a><span class="pp">println!</span>(</span>
<span id="cb5-26"><a href="#cb5-26"></a>    <span class="st">&quot;Immutable vector (heap-allocated) with two i64 values: {:?}&quot;</span><span class="op">,</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>    v1</span>
<span id="cb5-28"><a href="#cb5-28"></a>)<span class="op">;</span></span>
<span id="cb5-29"><a href="#cb5-29"></a></span>
<span id="cb5-30"><a href="#cb5-30"></a><span class="kw">let</span> <span class="kw">mut</span> v2<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i64</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb5-31"><a href="#cb5-31"></a>v2<span class="op">.</span>truncate(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-32"><a href="#cb5-32"></a><span class="pp">println!</span>(</span>
<span id="cb5-33"><a href="#cb5-33"></a>    <span class="st">&quot;Mutable vector (heap-allocated) with two i64 values: {:?}&quot;</span><span class="op">,</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>    v2</span>
<span id="cb5-35"><a href="#cb5-35"></a>)<span class="op">;</span></span>
<span id="cb5-36"><a href="#cb5-36"></a></span>
<span id="cb5-37"><a href="#cb5-37"></a><span class="kw">let</span> s1<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb5-38"><a href="#cb5-38"></a><span class="co">// Won&#39;t compile:</span></span>
<span id="cb5-39"><a href="#cb5-39"></a><span class="co">// s1.push(&#39;!&#39;);</span></span>
<span id="cb5-40"><a href="#cb5-40"></a><span class="pp">println!</span>(<span class="st">&quot;Immutable string (with heap-allocated buffer): {}&quot;</span><span class="op">,</span> s1)<span class="op">;</span></span>
<span id="cb5-41"><a href="#cb5-41"></a></span>
<span id="cb5-42"><a href="#cb5-42"></a><span class="kw">let</span> <span class="kw">mut</span> s2<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb5-43"><a href="#cb5-43"></a>s2<span class="op">.</span>push(<span class="ch">&#39;!&#39;</span>)<span class="op">;</span></span>
<span id="cb5-44"><a href="#cb5-44"></a><span class="pp">println!</span>(<span class="st">&quot;Mutable string (with heap-allocated buffer): {}&quot;</span><span class="op">,</span> s2)<span class="op">;</span></span></code></pre></div>
<p>Arguably the most important feature of Rust is a concept of <strong>ownership</strong>: for each value there is exactly one variable that owns it. This approach facilitates automatic resource management (when a variable goes out of scope, its value is dropped, for example, removed from the heap) and safety (eliminates problems like double free, resource leaking, data races, etc.). When a value is assigned to another variable (or passed to a function), the ownership is transferred to the new variable—the value is <strong>moved</strong>—and the old variable cannot be used again (you can imagine that it becomes “empty”). Only when assigning (or passing to a function) values of simple types (more precisely: types that implement the <code>Copy</code> trait, but more on traits later) are the values <strong>copied</strong>, and thus both variables can be still used as they own different values. To obtain a copy of a value of a complex type (more precisely, of a type that implements the <code>Clone</code> trait) you can use the <code>clone()</code> method. An example follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1"></a><span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="kw">let</span> i1 <span class="op">=</span> <span class="dv">42u32</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="co">// Above type of the variable is inferred from the type</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="co">// of the value: u32.</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="kw">let</span> v1 <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="co">// Above type of the vector&#39;s elements defaults to i32.</span></span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="kw">let</span> i2 <span class="op">=</span> i1<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="co">// Above value is copied so both variables own their own values.</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="kw">let</span> v2 <span class="op">=</span> v1<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="co">// Above value is moved so `v1` no longer owns the vector.</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="kw">let</span> v3 <span class="op">=</span> v2<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="co">// Above value is cloned so `v3` owns a copy of the vector.</span></span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="pp">println!</span>(<span class="st">&quot;Old integer: {}&quot;</span><span class="op">,</span> i1)<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="co">// Won&#39;t compile:</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>    <span class="co">// println!(&quot;Old vector: {:?}&quot;, v1);</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="pp">println!</span>(<span class="st">&quot;New integer: {}&quot;</span><span class="op">,</span> i2)<span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="pp">println!</span>(<span class="st">&quot;Moved vector: {:?}&quot;</span><span class="op">,</span> v2)<span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>    <span class="pp">println!</span>(<span class="st">&quot;Cloned vector: {:?}&quot;</span><span class="op">,</span> v3)<span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="op">}</span> <span class="co">// `v2` and `v3` go out of scope, so their values are dropped</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>  <span class="co">// (the vectors are deallocated). `v1` also goes out of scope</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>  <span class="co">// but since it doesn&#39;t own any value here, nothing is dropped</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>  <span class="co">// (thus the vector isn&#39;t dropped twice).</span></span></code></pre></div>
<p>Although the rule of the single owner is really handy from the perspectives of resource management and safety, without additional concepts, it would introduce significant burden on even simple tasks. For instance, consider a helper function that prints a vector:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">let</span> <span class="kw">mut</span> v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>    v <span class="op">=</span> print_by_value_and_return(v)<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="co">// Above vector is moved out of the variable to the function.</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="co">// Then it is returned by the function and reassigned (moved)</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="co">// to the variable.</span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>    print_by_value(v)<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    <span class="co">// Above vector is moved out of the variable to the function.</span></span>
<span id="cb7-11"><a href="#cb7-11"></a></span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="co">// Won&#39;t compile, `v` no longer owns the vector:</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="co">// println!(&quot;Vector: {:?}&quot;, v);</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="kw">fn</span> print_by_value_and_return(v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>    <span class="pp">println!</span>(<span class="st">&quot;The vector: {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>    v</span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="co">// The last expression of a function is its return value.</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="co">// There is no need to write `return v;` (but one can do so).</span></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="op">}</span></span>
<span id="cb7-22"><a href="#cb7-22"></a></span>
<span id="cb7-23"><a href="#cb7-23"></a><span class="kw">fn</span> print_by_value(v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>    <span class="pp">println!</span>(<span class="st">&quot;The vector: {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb7-25"><a href="#cb7-25"></a><span class="op">}</span> <span class="co">// `v` goes out of scope so the vector is dropped when the</span></span>
<span id="cb7-26"><a href="#cb7-26"></a>  <span class="co">// function ends.</span></span></code></pre></div>
<p>Fortunately, Rust features also <strong>references</strong>. <code>&amp;</code> is a referencing operator, <code>*</code> is a dereferencing operator. <code>&amp;</code> is also used to denote types that are references to some type. When a reference to a value is created, it does not change the owner of the value. Instead, it <strong>borrows</strong> the value from the owner. The “lease” ends when the variable that holds the reference goes out of scope. References are immutable unless they are declared with the <code>mut</code> keyword. The compiler verifies that at any given time there is either any number of immutable references to an object, or there is at most one mutable reference to the object. The compiler analyzes also <strong>lifetimes</strong> of all values to detect problems like dangling references. Rust provides also so-called <strong>slices</strong>, which are references to contiguous sequences of elements (e.g., to a part of an array, of a vector, of a string, and the like). An example follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">let</span> <span class="kw">mut</span> v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a>    print_by_reference(<span class="op">&amp;</span>v)<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="co">// Above function call performs immutable borrowing.</span></span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>    print_by_slice(<span class="op">&amp;</span>v[<span class="dv">0</span><span class="op">..</span><span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="co">// Above function call performs immutable borrowing</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="co">// of the range [0th element, 2nd element) of the vector.</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="co">// Multiple immutable references are safe:</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="kw">let</span> v_imm_ref_1 <span class="op">=</span> <span class="op">&amp;</span>v<span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="kw">let</span> v_imm_ref_2 <span class="op">=</span> <span class="op">&amp;</span>v<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="co">// Won&#39;t compile, there are already immutable references:</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="co">// let v_mut_ref = &amp;mut v;</span></span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a>    print_by_reference(v_imm_ref_2)<span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>    print_by_reference(v_imm_ref_1)<span class="op">;</span></span>
<span id="cb8-20"><a href="#cb8-20"></a></span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="co">// The above immutable references are not used below so</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="co">// it is now safe to have a mutable reference:</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>    <span class="kw">let</span> v_mut_ref <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> v<span class="op">;</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>    add_by_mut_reference(v_mut_ref)<span class="op">;</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>    print_by_reference(v_mut_ref)<span class="op">;</span></span>
<span id="cb8-26"><a href="#cb8-26"></a><span class="op">}</span></span>
<span id="cb8-27"><a href="#cb8-27"></a></span>
<span id="cb8-28"><a href="#cb8-28"></a><span class="kw">fn</span> print_by_reference(v<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>    <span class="pp">println!</span>(<span class="st">&quot;The vector: {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb8-30"><a href="#cb8-30"></a><span class="op">}</span></span>
<span id="cb8-31"><a href="#cb8-31"></a></span>
<span id="cb8-32"><a href="#cb8-32"></a><span class="kw">fn</span> add_by_mut_reference(v<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb8-33"><a href="#cb8-33"></a>    v<span class="op">.</span>push(<span class="dv">42</span>)<span class="op">;</span></span>
<span id="cb8-34"><a href="#cb8-34"></a><span class="op">}</span></span>
<span id="cb8-35"><a href="#cb8-35"></a></span>
<span id="cb8-36"><a href="#cb8-36"></a><span class="kw">fn</span> print_by_slice(v<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]) <span class="op">{</span></span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="pp">println!</span>(<span class="st">&quot;The vector: {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb8-38"><a href="#cb8-38"></a><span class="op">}</span></span>
<span id="cb8-39"><a href="#cb8-39"></a></span>
<span id="cb8-40"><a href="#cb8-40"></a><span class="co">// Won&#39;t compile, the lifetime of the returned reference is longer</span></span>
<span id="cb8-41"><a href="#cb8-41"></a><span class="co">// than the lifetime of the value:</span></span>
<span id="cb8-42"><a href="#cb8-42"></a><span class="co">// fn create_vector() -&gt; &amp;Vec&lt;u8&gt; {</span></span>
<span id="cb8-43"><a href="#cb8-43"></a><span class="co">//    let v: Vec&lt;u8&gt; = vec![0, 1];</span></span>
<span id="cb8-44"><a href="#cb8-44"></a><span class="co">//    &amp;v</span></span>
<span id="cb8-45"><a href="#cb8-45"></a><span class="co">// }</span></span></code></pre></div>
<p>The concepts discussed above are crucial features of Rust. You can read more about them in <a href="https://doc.rust-lang.org/book/">Rust Book</a> and in <a href="https://doc.rust-lang.org/rust-by-example/index.html">Rust by Example</a>.</p>
<p>Rust provides also many other useful features, of course. However, since the following concepts are present also in other programming languages (although they may be named there differently), and you probably already know them quite well, we do not discuss them here. Instead, we provide links to the Rust Book pointing at chapters that you should read yourself:</p>
<ul>
<li>Structs with methods (<a href="https://doc.rust-lang.org/book/ch05-00-structs.html">Chapter 5</a>),</li>
<li>Enums and pattern matching (<a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Chapter 6</a>),</li>
<li>Error handling (<a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Chapter 9</a>),</li>
<li>Traits and generics (<a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Chapter 10</a>),</li>
<li>Using simple macros (<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Chapter 19.5</a>),</li>
<li>Writing tests (<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Chapter 11</a>),</li>
<li>Creating, building and managing a Rust project (<a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">Chapter 1.3</a>).</li>
</ul>
<p>In the package with additional files for this lab there is an <code>examples/rust_overview.rs</code> file which presents of most of the features. You can run the examples using an <code>--example</code> option to <em>cargo</em>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource bash numberLines"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># In the main directory (i.e., where Cargo.toml is):</span></span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co"># Build and run the examples:</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ex">cargo</span> run --example rust_overview</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co"># Build and run tests of the examples:</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="ex">cargo</span> test --example rust_overview</span></code></pre></div>
<h2 id="small-assignment">Small Assignment</h2>
<p>This is only a trial assignment: it is <em>not</em> worth any points. However, you can get feedback that will be useful in assessing how subsequent assignments should be implemented, tested, and packaged. Therefore, we strongly recommend submitting your solution to this assignment.</p>
<p>Your task is to implement in Rust calculations of <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>. The first numbers in the sequence are 0 and 1. We start indexing from zero, so your implementation shall return:</p>
<ul>
<li>0 -&gt; 0</li>
<li>1 -&gt; 1</li>
<li>2 -&gt; 1</li>
<li>3 -&gt; 2</li>
<li>…</li>
</ul>
<p>More specifically, you are to implement a <code>Fibonacci</code> struct. It shall provide:</p>
<ol type="1">
<li>An associated function (see <a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#associated-functions">Chapter 5.3</a> of the Rust Book) <code>fibonacci</code>, which returns the n-th Fibonacci number. The calculations shall be performed using <code>u8</code> integers. To implement wrapping addition you can use the <code>wrapping_add()</code> method of <code>u8</code>.</li>
<li>An iterator (i.e., the <code>Iterator</code> trait), which iterates over the Fibonacci sequence (see <a href="https://doc.rust-lang.org/std/iter/index.html#implementing-iterator">Implementing Iterator</a> to learn how to implement a simple iterator). The calculations shall be performed using <code>u128</code> integers. To implement checked addition you can use the <code>checked_add()</code> method of <code>u128</code>.</li>
</ol>
<p>In the package with additional files for this lab there is a <code>solution.rs</code> file. It is a template for your solution. You are to implement the missing parts (marked there with the <code>unimplemented!</code> macro). Do not change the interface defined in the template, follow the requirements specified in the doc comments.</p>
<p>The package includes also a <code>main.rs</code> file, which demonstrates an exemplary usage of the <code>Fibonacci</code> struct, and some simple tests.</p>
<h2 id="additional-homework">Additional Homework</h2>
<p>Get comfortable with Rust. Browse the <a href="https://doc.rust-lang.org/book/">Rust Book</a> and the <a href="https://doc.rust-lang.org/rust-by-example/index.html">Rust by Example</a>. Play with the <code>examples/rust_overview.rs</code> file. Practice coding in Rust, because the next lab we will assume that you can write single-threaded programs in Rust.</p>
<hr />
<p>Authors: F. Plata, K. Iwanicki, M. Banaszek, W. Ciszewski.</p>
</section>
</body>
</html>
