<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="F. Plata, K. Iwanicki, M. Banaszek, W. Ciszewski" />
  <title>Distributed Systems Lab 07</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
body
{
font-family: Helvetica, sans;
background-color: #f0f0f0;
font-size: 12pt;
color: black;
text-decoration: none;
font-weight: normal;
}
section.content {
width: 19cm;
font-size: 12pt;
text-align: justify;
margin-left: auto;
margin-right: auto;
margin-top: 20pt;
background-color: white;
padding: 20pt;
}
h1
{
font-size: xx-large;
text-decoration: none;
font-weight: bold;
text-align: center;
}
h2
{
font-size: xx-large;
text-decoration: none;
font-weight: bold;
text-align: left;
border-bottom: 1px solid #808080;
}
h3
{
font-size: x-large;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h1 + h3 {
text-align: center;
}
h4
{
font-size: large;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h5
{
font-size: medium;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h6
{
font-size: medium;
text-decoration: none;
font-weight: normal;
text-align: left;
}
table
{
border-width: 1px;
border-spacing: 0px;
border-style: solid;
border-color: #808080;
border-collapse: collapse;
font-family: Times, serif;
font-size: 12pt;
color: black;
text-decoration: none;
font-weight: normal;
background-color: white;
}
td
{
border-width: 1px;
border-style: solid;
border-color: #808080;
padding: 3pt;
background-color: white;
}
th
{
border-width: 1px;
border-style: solid;
border-color: #808080;
padding: 3pt;
font-weight: bold;
background-color: #f0f0f0;
}
a:link {
color: blue;
text-decoration: none;
font-weight: normal;
}
a:visited {
color: blue;
text-decoration: none;
font-weight: normal;
}
a:hover {
text-decoration: underline;
font-weight: normal;
}
pre.sourceCode {
font-size: 90%;
}
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<section id="distributed-systems-lab-07" class="content">
<h1>Distributed Systems Lab 07</h1>
<h3 id="data-serialization-deserialization">Data serialization &amp; deserialization</h3>
<p>During the previous lab, we discussed stable storage and presented how to implement it on top of a filesystem. This lab discusses data serialization and deserialization, which are commonly used when different components of a distributed system require exchanging complex data structures. We will use files contained in <a href="./dslab07.tgz">this package</a>, which you should download and extract locally.</p>
<p>Moreover, this lab features no Small Assignment. Instead, you will be presented <a href="../LA2">the second Large Assignment</a>.</p>
<h2 id="learning-section">Learning Section</h2>
<h3 id="data-serialization-and-deserialization">Data serialization and deserialization</h3>
<p>When an in-memory object has to be transmitted (e.g., over a network to another component of a distributed system) or stored somewhere (e.g., in a file), it has to be transformed into a suitable data format.</p>
<p>A simple approach would be to simply use the in-memory representation. While Rust data layout is not stable (even across builds), we could enforce the lingua-franca layout of C with <a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#repr(C)</code></a> attribute:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1"></a><span class="at">#[</span>repr<span class="at">(</span>C<span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">struct</span> CStruct <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    a<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    b<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    c<span class="op">:</span> [<span class="dt">u16</span><span class="op">;</span> <span class="dv">3</span>]<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">}</span></span></code></pre></div>
<p>However, this format is useful only as long as the type does not contain any pointers or references. Moreover, transmutation of bytes into a structure is considered an unsafe operation in Rust.</p>
<p>In general, such a process is called <strong>serialization</strong> (or <strong>marshaling</strong>, although in some contexts the terms might not be considered to be exact synonyms). The reverse operation is named <strong>deserialization</strong>.</p>
<p>There are multiple data formats used for serialization. They can be roughly divided along two axes:</p>
<ul>
<li><strong>text-based</strong> vs <strong>binary</strong> formats,</li>
<li>having a required vs optional <strong>schema</strong> to make sense of the encoding.</li>
</ul>
<p>For example, <a href="https://www.json.org">JSON</a> is a well-known <em>text-based</em> format, very popular especially in the context of fronted development or within APIs serving requests external to the system. Data encoded as JSON is easily understandable by humans, which greatly facilitates debugging. However, for internal communication of specialized software, especially when large volumes of data are processed, <em>binary</em> formats are usually preferable, as they offer a more compact encoding. Some commonly known binary formats are: <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers (a.k.a. protobuf)</a>, <a href="https://avro.apache.org/">Apache Avro</a>, and <a href="https://msgpack.org/">MessagePack (compact JSON)</a>.</p>
<p>From the <em>schema</em> viewpoint, since both JSON and MessagePack always represent data as a combination of primitive types: numbers, strings, lists, mappings, etc., the receiver is not required to know the exact type of the message to interpret the bytes. (Although, multiple tools exist to define what constitutes a valid message.) The downside of <em>schema-less</em> formats is explicit typing of all constituents of complex data, which could be avoided if sides of communication shared a specification of the bytes stream. For instance, the <code>C</code> representation of the aforementioned structure is such a schema. Similarly, to use Protocol Buffers in a distributed system, we need to share the messages specification (<code>.proto</code> files) between components.</p>
<p>During this course, we will use the <strong><a href="https://crates.io/crates/bincode">bincode</a></strong> crate for serialization between Rust programs. The crate implements a custom binary format tailored to Rust (similar to <code>repr(C)</code>). But, how do we specify the schema?</p>
<h3 id="serde">Serde</h3>
<p><strong><a href="https://serde.rs/">Serde</a></strong> is a framework that facilitates <strong>ser</strong>ialization and <strong>de</strong>serialization of Rust data structures.</p>
<p>Any data structure that implements traits <code>Serialize</code> and <code>Deserialize</code> can be easily serialized into and deserialized from multiple data formats (see a list on the <a href="https://serde.rs/#data-formats">Serde website</a>), including bincode. To make a custom type serializable, the easiest way is to allow the implementation to be automatically generated (<em>derived</em>) by the framework. In our previous example, it is enough to replace the outer attribute:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">use</span> <span class="pp">serde::</span><span class="op">{</span>Serialize<span class="op">,</span> Deserialize<span class="op">};</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="at">#[</span>derive<span class="at">(</span>Serialize<span class="op">,</span> Deserialize<span class="at">)]</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">struct</span> CStruct <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    a<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    b<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    c<span class="op">:</span> [<span class="dt">u16</span><span class="op">;</span> <span class="dv">3</span>]<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="op">}</span></span></code></pre></div>
<p>An example how to serialize and deserialize data in Rust is provided in <code>examples/bincode_serde.rs</code>.</p>
<h4 id="under-the-hood">Under the hood</h4>
<p>Internally, Serde decouples the type schema (e.g., <code>CStruct</code>) from the wire data format (e.g., JSON, bincode) by employing a visitor pattern over intermediate representation (<a href="https://serde.rs/data-model.html">Serde data model</a>).</p>
<p>For serialization, the data format implements the <code>Serializer</code> trait handling 29 possible types: primitives, strings, arrays, structures, tuples, maps, unit, etc. The data structure implements the <code>Serialize</code> trait with a single method: <code>fn serialize&lt;S: Serializer&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;</code>, which encodes the <code>Self</code> type into the Serde data model by a series of calls to <code>Serializer</code> methods corresponding to the intermediate types.</p>
<p>Conversely, for deserialization, the data structure implements <code>Deserialize</code> and <code>Visitor</code>s with methods for handling all possible intermediate types. The data format implements <code>Deserializer</code>, accepting a byte sequence, which support two ways of operation:</p>
<ul>
<li>as reflected to serialization (for self-describing types), where the <code>Deserializer</code> drives the operation,</li>
<li>as analogous to serialization, where the <code>Deserialize</code> trait implementation drives the procedure.</li>
</ul>
<h2 id="additional-homework">Additional Homework</h2>
<p>Think about the safety of the deserialization procedure. Why <strong>transmutation</strong> (casting) from <code>&amp;[u8]</code> into <code>#repr(C) T</code> is unsafe even for relatively simple types? How can Serde guarantee a safe abstraction? For instance, you may consider an enumeration with an invalid tag number.</p>
<p>Moreover, you can learn about Serde limitations: what data formats cannot be represented?</p>
<hr />
<p>Authors: F. Plata, K. Iwanicki, M. Banaszek, W. Ciszewski, M. Matraszek</p>
</section>
</body>
</html>
